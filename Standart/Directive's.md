# Всякая-всячина
## Директивы в С++
Любой код написанный на С содержит в себе **`директивы`**, те самые строки начинающиеся с знака решётки **`#`**.   
Такие строки содержат команды адресованные непосредственно компилятору, и самой программой они не исполняются.  
Поэтому их можно и нужно использовать для улучшения читаемости и работоспособности кода.  
## Применение:
 - ### #define
> Позволяет определять переменные компилятора.  
> Возможно только **одно** определение с одинаковым именем.  
> При этом присваиваемые значения могут повторяться:
> ### Можно:
> ```C++
> #define Ten 10
> #define Dec 10
> ```
> ### Нельзя:
> ```C++
> #define DVA 20
> #define DVA 2
> ```

### Рассмотрим пример:  
Вместо того, чтобы писать:  
```C++
switch(A){
case 0 // код ошибки
   //code ...
  brake;
case 1 // код успеха
   //code ...
  brake;
case 2 // код остановки
   //code ...
  brake;
//и т.д.
}
```
Лучше сначала определить эти константы под понятными именами:
```C++
#define Err_code 1 // код ошибки
#define Suc_code 2 // код успеха
#define Wait_code 3 // код остановки

switch(A){
case Err_code 
   //code ...
  brake;
case Suc_code 
   //code ...
  brake;
case Wait_code 
   //code ...
  brake;
//и т.д.
}
```
Таким образом при компиляции любое упоминание переменной компилятора будет заменено на её значение,  
в соответствии с чем программа будет иметь изначальный функционал.  

Такая замена обеспечит прямое указание смысла константы. а так же позволит использовать её в любой  
части кода, которая имеет доступ к этому определению. При этом нет необходимости выделять память  
под такие переменные. 

- ### #undef
> Позволяет удалять ранее представленное определение.
Может быть полезно в некоторых целях.
```C++
#define TEN 10
int a = TEN;
#undef TEN
#define TEN "10"
```

- ### #include
> Позволяет включать части кода из других файлов, если какие либо части не используются - добавления  
> не происходит.  

Так, данная директива часто используется чтобы включить основную библиотеку ввода/вывода \<iostream\>  
Необходимо понимать, что добавлять с помощью этой директивы можно любой файл, но такой файл должен  
Содержать код подчиняющейся правилам синтаксиса С.
Есть два способа подключения файла:
- #### Глобальный   
    Используются \<\> и указывается название файла (\<string\>)  
    При этом необходимо учесть, что компилятор должен знать `где` находится этот файл.  
    Путь до стандартной библиотеки прописан в компиляторе по-умолчанию, но всё остальное, необходимо  
    указать при вызове программы-компилятора  
- #### Локальный
    Используются \"\" и указывается относительный путь файла.  
    Если файл находится в той же директории, то можно указать только его название.

- ### #if, #ifdef, #ifndef #endif:
> Данные директивы используются для логического ветвления кода до компиляции   
> `#endif` обозначает завершение тела `if`   

Отдельно стоит выделить директивы `#ifdef` и `#ifndef`. По своей сути они являются аналогами
`if(bool_var)` и `if(!bool_var)` соответственно, где буллевая переменная является ранее определённой
или **не определённой** переменной компилятора.

Это становится особенно полезно при написании заголовочных файлов (`.h` и `.hpp`).  
Всё что описано в таком файле включается в конструкцию из `#ifndef` и `#endif` при этом сразу после  
`#ifndef` даётся уникальное определение похожее на названием файла, которое помещается как аргумент `#ifndef`.  

```C++
// Содержимое My_Header_File.h
#ifndef MY_HEADER_FILE_H 
#define MY_HEADER_FILE_H // Название может быть любым, но принято писать так
// код определений
#endif
```

Таким образом при любом повторном подключении такого заголовочного файла, его содержимое, на самом деле,  
будет использовано только `один раз`, потому что при последующих подключениях `#ifndef` будет приводить 
к `false`, минуя последующие определения, обеспечивая тем самым однократное определение содержимого.  

Так же следует отметить что любой компилятор/кросскомпилятор имеет предопределённые переменные,  
отвечающие за параметры системы, такие как архитектура процессора, операционная система,  
версия стандартных библиотек, количество байт в `int`, и т.д.  
Проверка этих параметров, для включения/отключения определённых файлов и/или констант позволяет писать  
код, который можно сразу компилировать на множество платформ.
>Подробнее, смотри раздел **кросскомпиляция**.