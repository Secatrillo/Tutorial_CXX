# Классы и структуры
## Введение
Ранне рассмотренные типы данных имеют довольно простую структуру:
|Название|Значение|
|--------|--------|
|  name  |  Bob   |

Но что если необходимо хранить информацию о каком-то объекте и она представляет  
из себя несколько полей имеющих разную смысловую нагрузку и различные типы данных?  

|Название |Значение|
|---------|--------|
|  name   |  Bob   |
| number  |  51223 |
| address | Gre st.|

В таком случае становиться удобно использовать структуры данных:
```C++
struct person{
std::string name;
int number;
std::string address;
}; // обязательно ;
```
Это определение структуры `person`, для того чтобы использовать её  
необходимо создать хотя бы один экземпляр:
```C++
struct person student;
```
> Определение должно быть раньше, чем создание экземпляра!

В данном случае была создана экземпляр структуры `person` с именем `student`.  
Определение структуры будет являться "макетом" действий, которые можно проделывать над данной структурой.  
При этом это действие может сразу изменять несколько данных содержащихся в структуре. 

Для того чтобы придать какое либо значение полям данного экземпляра, можно сделать присвоение по соответствующему примеру:
```C++
student.name = "Bob";
student.number = 51223;
student.address = " Gre st.";
```

#### Почему это удобно?  
Потому что при появлении множества таких экземпляров, например создании массива, гораздо удобнее  
создать только `один` массив структур, нежели `несколько` массивов отдельных переменных, число которых может  
изменяться в процессе разработки.

## Разница между классами и структурами
Одним единственным отличием является то, что всё содержимое структуры по умолчанию является публичным.   
То есть любая переменная или метод могут быть вызваны внешними функциями.  
В свою очередь внутри класса всё по умолчанию, приватно, соответственно использовано "снаружи" быть не может. 

> `class`  - всё закрыто  
> `struct` - всё доступно

Это отличие можно устранить явно используя такие ключевые слова как:
- #### `private:`  
- #### `public:`  
Весь код который следует после этих указателей, поменяет свой доступ вне зависимости от того находится ли  
он внутри класса или структуры.

### Далее будут приводиться примеры со структурами, но всё это так же актуально и для классов.

## Методы структур  
По своей сути методы — это функции внутри структур.  
Казалось бы всё, но это не так.  
В то время как, если в функцию передать какую-либо переменную и изменить её значение внутри функции, ёё значение   
вне этой функции останется неизменным. То особенностью методов заключается возможность изменения значений содержащихся  
в структуре.

Добавим структуре `person` соответствующий метод:

```C++
struct person{
std::string name;
int number;
std::string address;

void change_name(std::string name_in){
    name = name_in;
}

}; 
``` 
Теперь после вызова соответствующего метода `student.change_name(Toby)` соответствующее значение `name` внутри экземпляра 
структуры будет изменено.  
Данный пример является наиболее примитивным, но с уложением содержимого структур (добавления комплексных типов), взаимодействия  
между самими полями, передачи их значений в другие функции вне структуры, практика использования методов становиться довольно востребованной.  
> Стоит учитывать, что если любая пользовательская `функция` содержит в качестве входных параметров некоторую `структуру`, то должна быть рассмотрена  
> возможность внедрения этой функции внутрь этой структуры `в качестве метода`.

> Как и в случаях с определением функций возможна `перегрузка методов`.

## Конструкторы и деструкторы